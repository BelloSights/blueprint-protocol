// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {CustomRevert} from '@uniswap/v4-core/src/libraries/CustomRevert.sol';
import {IPoolManager} from '@uniswap/v4-core/src/interfaces/IPoolManager.sol';
import {Hooks, IHooks} from '@uniswap/v4-core/src/libraries/Hooks.sol';
import {PoolId} from '@uniswap/v4-core/src/types/PoolId.sol';
import {PoolKey} from '@uniswap/v4-core/src/types/PoolKey.sol';
import {TickMath} from '@uniswap/v4-core/src/libraries/TickMath.sol';

import {FlaunchZap} from '@flaunch/zaps/FlaunchZap.sol';
import {Notifier} from '@flaunch/hooks/Notifier.sol';
import {PositionManager} from '@flaunch/PositionManager.sol';
import {WhitelistFairLaunch} from '@flaunch/subscribers/WhitelistFairLaunch.sol';
import {WhitelistPoolSwap} from '@flaunch/zaps/WhitelistPoolSwap.sol';

import {FlaunchTest} from '../FlaunchTest.sol';


contract WhitelistFairLaunchTest is FlaunchTest {

    /**
     * Whitelisted Addresses:
     *
     * Address      | Keccak256(Address)
     * address(300) | 0x975c2ff2d88bb33eba87988c482ba1a11cee273451aa76eb28acc668585ac527
     * address(301) | 0x193a3ae4da5049eb74cee39e4cf5827f7ce7b1d1d1775ef1c6311eb60558e6d5
     * address(302) | 0xbdaadd9f750d0166045bf387a364eadd28ba243e04512a47282aa5147a68e37f
     * address(303) | 0x232da9e50dad2971456a78fb5cd6ff6b75019984d6e918139ce990999420f979
     * address(304) | 0x2f605e086faac1d93117bbfbc18835d434e9405fadc1ca66faf4b864746daf34
     *
     * @dev Merkle data generated by https://lab.miguelmota.com/merkletreejs/example/
     */
    address internal constant WHITELISTED_USER = address(300);
    bytes32[] internal WHITELISTED_PROOF;
    bytes32[] internal INVALID_PROOF;
    bytes32[] internal EMPTY_PROOF;

    /// Set some valid test information
    PoolId internal constant VALID_POOL_ID = PoolId.wrap(bytes32('VALID_POOL_ID'));
    bytes32 internal constant VALID_MERKLE_ROOT = 0xf0032a2ce51fb002ffdbef2becaffbc1ec8140593eaf7ca45d93e0c23302367c;
    string internal constant VALID_MERKLE_IPFS = 'ipfs://0x123';

    /// Define some Fair Launch parameters
    uint INITIAL_TOKEN_FAIR_LAUNCH = 1e18;

    IPoolManager.SwapParams swapParams = IPoolManager.SwapParams({
        zeroForOne: true,
        amountSpecified: -0.001 ether,
        sqrtPriceLimitX96: TickMath.MIN_SQRT_PRICE + 1
    });

    constructor () {
        // Deploy our platform
        _deployPlatform();

        // Define our proofs
        WHITELISTED_PROOF = new bytes32[](3);
        WHITELISTED_PROOF[0] = hex'193a3ae4da5049eb74cee39e4cf5827f7ce7b1d1d1775ef1c6311eb60558e6d5';
        WHITELISTED_PROOF[1] = hex'ae4a5f543a1c53c50596bac5abe21d88618abe04dac2c884949ec79d26ecca41';
        WHITELISTED_PROOF[2] = hex'2f605e086faac1d93117bbfbc18835d434e9405fadc1ca66faf4b864746daf34';

        INVALID_PROOF = new bytes32[](2);
        INVALID_PROOF[0] = hex'cddd06ffd7f3008e5bfd66edc4719f3b5a6dfca8b61da45256d709b6f8ba9a37';
        INVALID_PROOF[1] = hex'5f1b56e2945ce37b1b46866c57180b1dd3311d7c948222a8fc061595db8782a6';

        EMPTY_PROOF = new bytes32[](0);

        // Deal flETH to our test users that will be making swaps
        _depositFLETH(address(this), 100 ether);
        flETH.approve(address(whitelistPoolSwap), 100 ether);
        flETH.approve(address(poolSwap), 100 ether);

        _depositFLETH(WHITELISTED_USER, 100 ether);
        vm.startPrank(WHITELISTED_USER);
        flETH.approve(address(whitelistPoolSwap), 100 ether);
        flETH.approve(address(poolSwap), 100 ether);
        vm.stopPrank();

        // We also need flETH present in the {PoolManager} for swaps to be successful
        _depositFLETH(address(poolManager), 100 ether);
    }

    /**
     * FlaunchZap
     */

    function test_FlaunchZap_CanFlaunch_WithWhitelist() public withSubscriber {
        _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);
    }

    function test_FlaunchZap_CanFlaunch_WithWhitelist_AndRefundOverpay() public withSubscriber {
        // Deal enough ETH to overpay
        deal(address(this), 1 ether);

        // Flaunch a whitelist pool
        _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 1 ether);

        assertEq(payable(address(this)).balance, 1 ether);
    }

    function test_FlaunchZap_CanFlaunch_WithoutWhitelist() public withSubscriber {
        _flaunchToken('', VALID_MERKLE_IPFS, 0, 0);
    }

    function test_FlaunchZap_CannotFlaunch_WithoutZapApproved() public withSubscriber {
        // Unapprove our zap
        whitelistFairLaunch.setWhitelistZap(address(flaunchZap), false);

        // Revert if merkle root specified
        vm.expectRevert(WhitelistFairLaunch.CallerNotWhitelistZap.selector);
        _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        // Not an issue if no merkle root specified
        _flaunchToken('', VALID_MERKLE_IPFS, 0, 0);
    }

    /**
     * PoolSwap
     */

    function test_PoolSwap_CannotSwap_Whitelist_InFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 1 ether, 0);

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        vm.expectRevert(
            abi.encodeWithSelector(
                CustomRevert.WrappedError.selector,
                address(positionManager),
                IHooks.afterSwap.selector,
                abi.encodeWithSelector(WhitelistFairLaunch.CallerNotWhitelisted.selector),
                abi.encodeWithSelector(Hooks.HookCallFailed.selector)
            )
        );

        poolSwap.swap({
            _key: poolKey,
            _params: swapParams
        });

        vm.stopPrank();
    }

    function test_PoolSwap_CanSwap_Whitelist_AfterFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        vm.warp(block.timestamp + 30 days);

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        poolSwap.swap({
            _key: poolKey,
            _params: swapParams
        });

        vm.stopPrank();
    }

    function test_PoolSwap_CannotOverBuy_Whitelist_InFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        // Update our swap parameters to increase the buy amount. This will buy out the
        // Fair Launch token allocation.
        swapParams.amountSpecified = -2 ether;

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        vm.expectRevert(
            abi.encodeWithSelector(
                CustomRevert.WrappedError.selector,
                address(positionManager),
                IHooks.afterSwap.selector,
                abi.encodeWithSelector(WhitelistFairLaunch.CallerNotWhitelisted.selector),
                abi.encodeWithSelector(Hooks.HookCallFailed.selector)
            )
        );

        poolSwap.swap({
            _key: poolKey,
            _params: swapParams
        });

        vm.stopPrank();
    }

    /**
     * WhitelistPoolSwap
     */

    function test_WhitelistPoolSwap_CanSwap_NonWhitelist_InFairLaunch() public withSubscriber {
        // Flaunch a token that is not whitelisted
        PoolKey memory poolKey = _flaunchToken('', VALID_MERKLE_IPFS, 0, 0);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: EMPTY_PROOF
        });
    }

    function test_WhitelistPoolSwap_CanSwap_NonWhitelist_AfterFairLaunch() public withSubscriber {
        // Flaunch a token that is not whitelisted
        PoolKey memory poolKey = _flaunchToken('', VALID_MERKLE_IPFS, 0, 0);

        vm.warp(block.timestamp + 30 days);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: EMPTY_PROOF
        });
    }

    function test_WhitelistPoolSwap_CanSwap_Whitelist_InFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: WHITELISTED_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CanSwap_Whitelist_AfterFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        vm.warp(block.timestamp + 30 days);

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: WHITELISTED_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CannotSwap_Whitelist_InFairLaunch_IfNotSetInSubscriber() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        // Remove the WhitelistPoolSwap contract so that it no longer has permissions to
        // make whitelist swaps.
        whitelistFairLaunch.setWhitelistPoolSwap(address(0));

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        vm.expectRevert(
            abi.encodeWithSelector(
                CustomRevert.WrappedError.selector,
                address(positionManager),
                IHooks.afterSwap.selector,
                abi.encodeWithSelector(WhitelistFairLaunch.CallerNotWhitelisted.selector),
                abi.encodeWithSelector(Hooks.HookCallFailed.selector)
            )
        );

        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: WHITELISTED_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CanSwap_Whitelist_AfterFairLaunch_IfNotSetInSubscriber() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        vm.warp(block.timestamp + 30 days);

        // Remove the WhitelistPoolSwap contract so that it no longer has permissions to
        // make whitelist swaps.
        whitelistFairLaunch.setWhitelistPoolSwap(address(0));

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: WHITELISTED_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CanOverBuy_Whitelist_InFairLaunch() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        // Update our swap parameters to increase the buy amount. This will buy out the
        // Fair Launch token allocation.
        swapParams.amountSpecified = -2 ether;

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: WHITELISTED_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CannotSwap_Whitelist_InFairLaunch_WithInvalidProof() public withSubscriber {
        // Flaunch a token that is whitelisted
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 0, 0);

        vm.startPrank(WHITELISTED_USER);

        // Action a swap that hits a non-whitelist token during fair launch
        vm.expectRevert(WhitelistPoolSwap.MerkleVerificationFailed.selector);
        whitelistPoolSwap.swap({
            _key: poolKey,
            _params: swapParams,
            _merkleProof: INVALID_PROOF
        });

        vm.stopPrank();
    }

    function test_WhitelistPoolSwap_CannotSwap_MoreThanMaxTokens(uint64 _swap1, uint64 _swap2) public withSubscriber {
        // We don't want any zero value swaps. They are dumb.
        vm.assume(_swap1 != 0);
        vm.assume(_swap2 != 0);

        // Ensure our first swap is below our limit, and that the second swap will push us over the
        // limit. We cap their type at `uint128` as we need to convert them to `int` later in our test.
        vm.assume(_swap1 <= INITIAL_TOKEN_FAIR_LAUNCH / 2);

        vm.assume(_swap2 > INITIAL_TOKEN_FAIR_LAUNCH / 2);
        vm.assume(_swap2 < INITIAL_TOKEN_FAIR_LAUNCH);

        // Flaunch a token that is whitelisted, with a max token allocation of 50% of the fair launch
        PoolKey memory poolKey = _flaunchToken(VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, INITIAL_TOKEN_FAIR_LAUNCH / 2, 0);

        vm.startPrank(WHITELISTED_USER);

        // Make our first buy amount under our limit
        swapParams.amountSpecified = -int(uint(_swap1));
        whitelistPoolSwap.swap(poolKey, swapParams, WHITELISTED_PROOF);

        // Make our second buy that will go over our limit
        swapParams.amountSpecified = -int(uint(_swap2));

        vm.expectRevert(WhitelistPoolSwap.TooManyTokensClaimed.selector);
        whitelistPoolSwap.swap(poolKey, swapParams, WHITELISTED_PROOF);

        vm.stopPrank();
    }

    /**
     * WhitelistFairLaunch
     */

    function test_CanSubscribe() public {
        // Register our {Notifier} used by the {PositionManager}
        Notifier notifier = positionManager.notifier();

        // Attach a {WhitelistPoolSwap} contract
        _setWhitelistPoolSwap(address(whitelistPoolSwap));

        vm.expectEmit();
        emit Notifier.Subscription(address(whitelistFairLaunch));

        // We can now subscribe successfully
        notifier.subscribe(address(whitelistFairLaunch), '');
    }

    function test_CannotSubscribe_WithoutPoolSwapAddress() public {
        // Register our {Notifier} used by the {PositionManager}
        Notifier notifier = positionManager.notifier();

        // Since we are trying to subscribe without a {WhitelistPoolSwap} contract assigned
        // we should get reverted.
        vm.expectRevert(Notifier.SubscriptionReverted.selector);
        notifier.subscribe(address(whitelistFairLaunch), '');
    }

    function test_CanSetWhitelist(address _approvedCaller) public {
        // Approve our approved caller
        whitelistFairLaunch.setWhitelistZap(_approvedCaller, true);

        // Confirm that before the whitelist is set, we have an empty data struct
        (bytes32 merkleRoot, string memory merkleIpfs, uint maxTokens, bool active, bool exists) = whitelistFairLaunch.whitelistMerkles(VALID_POOL_ID);
        assertEq(merkleRoot, bytes32(''));
        assertEq(merkleIpfs, '');
        assertEq(maxTokens, 0);
        assertFalse(active);
        assertFalse(exists);

        // Make a call with the unapproved caller
        vm.startPrank(_approvedCaller);

        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistCreated(VALID_POOL_ID, VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 1e27);

        // Set our whitelist
        whitelistFairLaunch.setWhitelist({
            _poolId: VALID_POOL_ID,
            _root: VALID_MERKLE_ROOT,
            _ipfs: VALID_MERKLE_IPFS,
            _maxTokens: 1e27
        });

        // Confirm that the whitelist for set against the PoolId
        (merkleRoot, merkleIpfs, maxTokens, active, exists) = whitelistFairLaunch.whitelistMerkles(VALID_POOL_ID);
        assertEq(merkleRoot, VALID_MERKLE_ROOT);
        assertEq(merkleIpfs, VALID_MERKLE_IPFS);
        assertEq(maxTokens, 1e27);
        assertTrue(active);
        assertTrue(exists);

        vm.stopPrank();
    }

    function test_CannotSetWhitelist_IfAlreadySet() public {
        // Approve our approved caller
        whitelistFairLaunch.setWhitelistZap(address(this), true);

        // Set our whitelist
        whitelistFairLaunch.setWhitelist(VALID_POOL_ID, VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 1e27);

        // Try and set the whitelist for the same pool. This should revert as we don't want
        // the whitelist to be overwritten.
        vm.expectRevert(WhitelistFairLaunch.WhitelistAlreadyExists.selector);
        whitelistFairLaunch.setWhitelist(VALID_POOL_ID, VALID_MERKLE_ROOT, VALID_MERKLE_IPFS, 1e27);
    }

    function test_CannotSetWhitelist_WithUnapprovedCaller(address _approvedCaller, address _unapprovedCaller) public {
        // Ensure that the approved caller is not the same address as the unapproved caller
        vm.assume(_approvedCaller != _unapprovedCaller);
        vm.assume(_unapprovedCaller != address(flaunchZap));

        // Approve our approved caller
        whitelistFairLaunch.setWhitelistZap(_approvedCaller, true);

        // Make a call with the unapproved caller
        vm.startPrank(_unapprovedCaller);

        vm.expectRevert(WhitelistFairLaunch.CallerNotWhitelistZap.selector);
        whitelistFairLaunch.setWhitelist({
            _poolId: VALID_POOL_ID,
            _root: VALID_MERKLE_ROOT,
            _ipfs: VALID_MERKLE_IPFS,
            _maxTokens: 1e27
        });

        vm.stopPrank();

        // We can now unapprove our first whitelist zap
        whitelistFairLaunch.setWhitelistZap(_approvedCaller, false);

        // Make a call with the (now) unapproved, approved caller
        vm.startPrank(_approvedCaller);

        vm.expectRevert(WhitelistFairLaunch.CallerNotWhitelistZap.selector);
        whitelistFairLaunch.setWhitelist({
            _poolId: VALID_POOL_ID,
            _root: VALID_MERKLE_ROOT,
            _ipfs: VALID_MERKLE_IPFS,
            _maxTokens: 1e27
        });

        vm.stopPrank();
    }

    function test_CanSetWhitelistPoolSwap(address _address1, address _address2) public {
        // Confirm the initial value set in the constructor
        assertEq(whitelistFairLaunch.whitelistPoolSwap(), address(0));

        // Update the address
        _setWhitelistPoolSwap(_address1);

        // Update to the same address, confirm that it does not revert
        _setWhitelistPoolSwap(_address1);

        // Update to a new address
        _setWhitelistPoolSwap(_address2);

        // Set to address(0), which will prevent future swaps
        _setWhitelistPoolSwap(address(0));
    }

    function test_CannotSetWhitelistPoolSwap_WithoutOwner(address _caller) public {
        vm.assume(_caller != msg.sender);

        vm.startPrank(_caller);

        vm.expectRevert(UNAUTHORIZED);
        whitelistFairLaunch.setWhitelistPoolSwap(address(0));

        vm.stopPrank();
    }

    function test_CanApproveWhitelistZap(address _whitelistZap) public {
        // Confirm that the whitelist zap is not currently approved
        assertFalse(whitelistFairLaunch.whitelistZaps(_whitelistZap));

        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistZapUpdated(_whitelistZap, true);

        // Approve our whitelist zap address
        whitelistFairLaunch.setWhitelistZap(_whitelistZap, true);

        // Confirm that it is now flagged as whitelisted
        assertTrue(whitelistFairLaunch.whitelistZaps(_whitelistZap));
    }

    function test_CanApproveWhitelistZap_MultipleZaps(address[] calldata _zaps) public {
        // Iterate through our addresses and approve them all
        for (uint i; i < _zaps.length; ++i) {
            whitelistFairLaunch.setWhitelistZap(_zaps[i], true);
        }

        // Now loop through again and confirm that all are approved at the same time
        for (uint i; i < _zaps.length; ++i) {
            assertTrue(whitelistFairLaunch.whitelistZaps(_zaps[i]));
        }

        // Iterate through our addresses and unapprove them all
        for (uint i; i < _zaps.length; ++i) {
            whitelistFairLaunch.setWhitelistZap(_zaps[i], false);
        }

        // Now loop through again and confirm that all are unapproved at the same time
        for (uint i; i < _zaps.length; ++i) {
            assertFalse(whitelistFairLaunch.whitelistZaps(_zaps[i]));
        }
    }

    function test_CanApproveWhitelistZap_MultipleTimes(address _whitelistZap) public {
        // Confirm that the whitelist zap is not currently approved
        assertFalse(whitelistFairLaunch.whitelistZaps(_whitelistZap));

        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistZapUpdated(_whitelistZap, true);

        // Approve our whitelist zap address
        whitelistFairLaunch.setWhitelistZap(_whitelistZap, true);

        // Confirm that it is now flagged as whitelisted
        assertTrue(whitelistFairLaunch.whitelistZaps(_whitelistZap));

        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistZapUpdated(_whitelistZap, true);

        // Make the same approval call again for our whitelist zap address
        whitelistFairLaunch.setWhitelistZap(_whitelistZap, true);

        // Confirm that it is still flagged as whitelisted
        assertTrue(whitelistFairLaunch.whitelistZaps(_whitelistZap));
    }

    function test_CanUnapproveWhitelistZap(address _whitelistZap) public {
        // Approve our whitelist zap address
        whitelistFairLaunch.setWhitelistZap(_whitelistZap, true);

        // Confirm that it is now flagged as whitelisted
        assertTrue(whitelistFairLaunch.whitelistZaps(_whitelistZap));

        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistZapUpdated(_whitelistZap, false);

        // Unapprove our whitelist zap address
        whitelistFairLaunch.setWhitelistZap(_whitelistZap, false);

        // Confirm that it is no longer flagged as whitelisted
        assertFalse(whitelistFairLaunch.whitelistZaps(_whitelistZap));
    }

    function test_CannotSetWhitelistZap_WithoutOwner(address _caller) public {
        vm.assume(_caller != address(this));

        vm.startPrank(_caller);

        vm.expectRevert(UNAUTHORIZED);
        whitelistFairLaunch.setWhitelistZap(address(1), true);

        vm.stopPrank();
    }

    /**
     * Sets and asserts a whitelist pool swap call.
     */
    function _setWhitelistPoolSwap(address _contract) internal {
        // Confirm that the event is emitted correctly
        vm.expectEmit();
        emit WhitelistFairLaunch.WhitelistPoolSwapUpdated(_contract);

        // Update the {WhitelistPoolSwap} contract address
        whitelistFairLaunch.setWhitelistPoolSwap(_contract);

        // Confirm that the contract address updated correctly
        assertEq(whitelistFairLaunch.whitelistPoolSwap(), _contract);
    }

    function _flaunchToken(bytes32 _root, string memory _ipfs, uint _maxTokens, uint _msgValue) internal returns (PoolKey memory) {
        // Flaunch a whitelist pool
        (address memecoin,,) = flaunchZap.flaunch{value: _msgValue}({
            _flaunchParams: PositionManager.FlaunchParams({
                name: 'Token',
                symbol: 'TKN',
                tokenUri: VALID_MERKLE_IPFS,
                initialTokenFairLaunch: INITIAL_TOKEN_FAIR_LAUNCH,
                fairLaunchDuration: 30 minutes,
                premineAmount: 0,
                creator: address(this),
                creatorFeeAllocation: 20_00,
                flaunchAt: block.timestamp,
                initialPriceParams: abi.encode(5000e6),
                feeCalculatorParams: abi.encode(1000)
            }),
            _whitelistParams: FlaunchZap.WhitelistParams({
                merkleRoot: _root,
                merkleIPFSHash: _ipfs,
                maxTokens: _maxTokens
            }),
            _airdropParams: FlaunchZap.AirdropParams({
                airdropIndex: 0,
                airdropAmount: 0,
                airdropEndTime: 0,
                merkleRoot: bytes32(''),
                merkleIPFSHash: ''
            }),
            _treasuryManagerParams: FlaunchZap.TreasuryManagerParams({
                manager: address(0),
                initializeData: abi.encode(''),
                depositData: abi.encode('')
            })
        });

        // Define our PoolKeys
        return positionManager.poolKey(memecoin);
    }

    function _depositFLETH(address _recipient, uint _amount) internal {
        deal(_recipient, _amount);

        vm.prank(_recipient);
        flETH.deposit{value: _amount}();
    }

    modifier withSubscriber() {
        whitelistFairLaunch.setWhitelistPoolSwap(address(whitelistPoolSwap));
        positionManager.notifier().subscribe(address(whitelistFairLaunch), '');
        _;
    }

}
